/**
 * Items routes module
 * Generated by AI chat for production-ready API structure
 */

const express = require('express');
const { validateItem, validatePagination } = require('../middleware/validation');

const router = express.Router();

// In-memory storage (in production, this would be a database service)
let items = [
  { 
    id: 1, 
    name: 'AI Generated Item 1', 
    description: 'This item was created by AI chat',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },
  { 
    id: 2, 
    name: 'AI Generated Item 2', 
    description: 'Another AI-generated item',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }
];

/**
 * @route   GET /api/items
 * @desc    Get all items with pagination and search
 * @access  Public
 */
router.get('/', validatePagination, (req, res) => {
  try {
    const { page = 1, limit = 10, search, sortBy = 'createdAt', order = 'desc' } = req.query;
    const pageNum = parseInt(page);
    const limitNum = parseInt(limit);
    
    let filteredItems = [...items];
    
    // Search functionality
    if (search) {
      filteredItems = filteredItems.filter(item => 
        item.name.toLowerCase().includes(search.toLowerCase()) ||
        item.description.toLowerCase().includes(search.toLowerCase())
      );
    }
    
    // Sorting
    filteredItems.sort((a, b) => {
      const aValue = a[sortBy];
      const bValue = b[sortBy];
      
      if (order === 'desc') {
        return bValue > aValue ? 1 : -1;
      } else {
        return aValue > bValue ? 1 : -1;
      }
    });
    
    // Pagination
    const startIndex = (pageNum - 1) * limitNum;
    const endIndex = pageNum * limitNum;
    const paginatedItems = filteredItems.slice(startIndex, endIndex);
    
    res.json({
      success: true,
      data: {
        items: paginatedItems,
        pagination: {
          currentPage: pageNum,
          totalPages: Math.ceil(filteredItems.length / limitNum),
          totalItems: filteredItems.length,
          itemsPerPage: limitNum,
          hasNextPage: endIndex < filteredItems.length,
          hasPrevPage: pageNum > 1
        }
      }
    });
  } catch (error) {
    console.error('Error fetching items:', error);
    res.status(500).json({ 
      success: false,
      error: 'Internal server error', 
      message: 'Failed to fetch items' 
    });
  }
});

/**
 * @route   POST /api/items
 * @desc    Create a new item
 * @access  Public
 */
router.post('/', validateItem, (req, res) => {
  try {
    const { name, description } = req.body;
    
    const newItem = {
      id: items.length > 0 ? Math.max(...items.map(item => item.id)) + 1 : 1,
      name: name.trim(),
      description: description ? description.trim() : '',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    items.push(newItem);
    
    res.status(201).json({
      success: true,
      message: 'Item created successfully',
      data: newItem
    });
  } catch (error) {
    console.error('Error creating item:', error);
    res.status(500).json({ 
      success: false,
      error: 'Internal server error', 
      message: 'Failed to create item' 
    });
  }
});

/**
 * @route   GET /api/items/:id
 * @desc    Get item by ID
 * @access  Public
 */
router.get('/:id', (req, res) => {
  try {
    const id = parseInt(req.params.id);
    const item = items.find(item => item.id === id);
    
    if (!item) {
      return res.status(404).json({
        success: false,
        error: 'Not found',
        message: `Item with ID ${id} not found`
      });
    }
    
    res.json({
      success: true,
      data: item
    });
  } catch (error) {
    console.error('Error fetching item:', error);
    res.status(500).json({ 
      success: false,
      error: 'Internal server error', 
      message: 'Failed to fetch item' 
    });
  }
});

module.exports = router;

